/*
 * Copyright 2015 Martin Garcia Carmueja 
 * 
 *  This file is part of the Myoelectric Personal Training and Control Environment (MPTCE).
 *
 *  MPTCE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  MPTCE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with MPTCE.  If not, see <http://www.gnu.org/licenses/>.
 */

using System;
using System.IO;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.Collections.Concurrent;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using EMGFramework.DataProvider;
using EMGFramework.Pipelines;
using EMGFramework.ValueObjects;
using EMGFramework.File;
using EMGFramework.Utility;
using MPTCE.Dialogs;


namespace MPTCE.Model
{
    /// <summary>
    /// Model for the acquisition stage. This class holds the logic that will be called from the viewModel
    /// </summary>
    public class AcqModel:INotifyPropertyChanged
    {

        

        //Data acquisition pipeline
        private Pipeline _acqPipeline = null;
        //Stages for the data acquisition pipeline
        private AcquisitionController _recordingController;
        private Recorder _recordingStage;
        private ThresholdEngine _thresholdEngine;
        //EMGDataProvider object used to feed the data acquisition pipeline
        private EMGDataProvider _dataProvider = null;

        /// <summary>
        /// Gives access to the rectify property of the valueshifter stage, so that the viewModel can redraw its graphs
        /// correctly.
        /// </summary>
        public bool rectify
        {
            get 
            {
                if (_thresholdEngine != null) return _thresholdEngine.rectify;
                else return true;
            }
        }


        /// <summary>
        /// Event delegate that is called whenever an observed property in the Model changes, so that the event 
        /// </summary>
        public event PropertyChangedEventHandler PropertyChanged;

        public void NotifyPropertyChanged(string propName)
        {
            if (this.PropertyChanged != null)
                this.PropertyChanged(this, new PropertyChangedEventArgs(propName));
        }


        /// <summary>
        /// Event forwarding handler for whatever event is coming form the model's RecordingConfig object
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void _recordingConfig_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            this.NotifyPropertyChanged(e.PropertyName);
        }


        /// <summary>
        /// Handler for PropertyChanged events generated by this model itself
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void AcqModel_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            switch (e.PropertyName)
            {
                case "simultMovements":
                    if (recordingConfig.schedule.Count > 0) recordingConfig.schedule.Clear();

                    //Here we need to regenerate the recording schedule with the new movement combination
                    ComposeSchedule();
                    //If we don't get any schedule items (because all simultaneous combinations are impossible)
                    //we try with fewer simultaneous movements down to 1. Decreasing simultMovements here should
                    //trigger a recursive call to this handler.
                    if ((recordingConfig.schedule.Count == 0) && (simultMovements > 1))
                        simultMovements--;

                    break;
                case "detectThresholds":
                    recordingValid = false;
                    break;
                default:
                    break;

            }
        }


        private void SelectedMovements_CollectionChanged(object sender, NotifyCollectionChangedEventArgs args)
        {

            //Here we call a method that will create or recreate a schedule on the basis of the selected movements
            recordingConfig.schedule.Clear();
            ComposeSchedule();

            //If we get an empty schedule, this means that possibly too much simultaneous movements in relation
            //to the selected individual movements are configured. We decrease the number of simultaneous movements
            //and let the handler for that property do the rest.

            if ((recordingConfig.schedule.Count == 0) && (simultMovements > 1))
                simultMovements--;

        }



        /// <summary>
        /// A shortcut to the recordingEventQueue of the RecordingController object used in this model
        /// </summary>
        public BlockingCollection<int> recordingEventQueue
        {

            get
            {
                if (_recordingController != null) return _recordingController.recordingEventQueue;
                else return null;
            }
        }


        private ObservableCollection<Movement> _selectedMovements;

        /// <summary>
        /// Collection containing the selected items in the list of movements shown on the UI of
        /// the acquisition stage.
        /// </summary>
        public ObservableCollection<Movement> selectedMovements
        {
            get
            {
                return _selectedMovements;
            }

        }



        private bool _detectThresholds = false;


        /// <summary>
        /// Indicates whether or not the program will be performing threshold detection. This
        /// will enable the shifting of the signal to positive values at the ThresholdEngine stage during recording. 
        /// Conversion of an already loaded recording or recorded data, and the propagation of the setting, so that 
        /// functions in other stages can be conveniently enabled or disabled can also be performed.
        /// </summary>
        public bool detectThresholds
        {
            get
            {
                return _detectThresholds;
            }

            set
            {
                if (_detectThresholds != value)
                {
                    _detectThresholds = value;
                    this.NotifyPropertyChanged("detectThresholds");
                }
            }
        }        



        private int _simultMovements;
        
        /// <summary>
        /// Number of simultaneous movements currently selected
        /// </summary>
        public int simultMovements
        {
            get
            {
                return _simultMovements;
            }

            set
            {
                if (value != _simultMovements)
                {
                    _simultMovements = value;
                    this.NotifyPropertyChanged("simultMovements");
                }
            }
        }


        private RecordingConfig _recordingConfig;
        /// <summary>
        /// Valid recording configuration for a new recording or for the currently loaded recording
        /// </summary>
        public RecordingConfig recordingConfig
        {
            get
            {
                return _recordingConfig;
            }

            private set
            {
                if (_recordingConfig != value)
                {
                    if (_recordingConfig != null)
                        _recordingConfig.PropertyChanged -= _recordingConfig_PropertyChanged;

                    _recordingConfig = value;
                    _recordingConfig.PropertyChanged += _recordingConfig_PropertyChanged;
                    this.NotifyPropertyChanged("recordingConfig");
                }
            }
        }


        /// <summary>
        /// This property is the interface through which client classes can select one of the
        /// EMGDataProvider implementations supported by this model. Supported EMGDataProvider-derived
        /// classes are detected and instantiated at run-time by using the GenericFactory singleton.
        /// </summary>
        public string dataProvider
        {
            get
            {
                if (_dataProvider != null)
                    return (string)_dataProvider.GetType().GetProperty("ID").GetValue(null, null);
                else return null;
            }

            set
            {
                if (
                    GenericFactory<EMGDataProvider>.Instance.SupportedProducts.Contains(value)
                    && (
                        _dataProvider == null
                        || (string)_dataProvider.GetType().GetProperty("ID").GetValue(null, null) != value
                       )
                    )
                {
                    //We use the InstanceManager<EMGDataProvider> as a cache 
                    //for generating EMGDataProvider objects only once

                    _dataProvider = InstanceManager<EMGDataProvider>.Instance.Retrieve(value);
                    if (_dataProvider == null)
                    {
                        _dataProvider = GenericFactory<EMGDataProvider>.Instance.CreateProduct(value);
                        InstanceManager<EMGDataProvider>.Instance.Register(_dataProvider);

                        if (_dataProvider.readsFromFile)
                        {
                            _dataProvider.knownMovements = Properties.Settings.Default.AcqMovementsList;
                            _dataProvider.allowedComplexMovements = Properties.Settings.Default.AcqAllowedMovements;
                            _dataProvider.movementSelector = new DialogMovementSelector();
                        }
                    }

                    _dataProvider.loop = false;

                    this.NotifyPropertyChanged("dataProvider");
                }
            }
        }



        private Recording _recordedData;
        /// <summary>
        /// It holds the data recorded or loaded from a file
        /// </summary>
        public Recording recordedData
        {
            get
            {
                return _recordedData;
            }
            private set
            {
                if (_recordedData != value)
                {
                    _recordedData = value;
                    this.NotifyPropertyChanged("recordedData");
                }
            }
        }


        private bool _recordingValid;
        /// <summary>
        /// True if the model contains a valid recording.
        /// </summary>
        public bool recordingValid
        {
            get
            {
                return _recordingValid;
            }
            private set
            {
                if (_recordingValid != value)
                {
                    _recordingValid = value;
                    this.NotifyPropertyChanged("recordingValid");
                }
            }
        }


        /// <summary>
        /// Used to provide monitoring of the data being acquired.
        /// </summary>
        public BlockingCollection<object> dataMonitor
        {
            get
            {
                if (_recordingStage != null) return _recordingStage.dataMonitor;
                else return null;
            }
        }


        /// <summary>
        /// Provides monitoring of the progress of a given recording schedule item
        /// </summary>
        public BlockingCollection<int> progressMonitor
        {
            get
            {
                if (_recordingController != null) return _recordingController.progressMonitor;
                else return null;
            }
        }



        /// <summary>
        /// List of usable IFileReadWriter objects
        /// </summary>
        private List<IFileReadWriter> _fileReadWriters;



        /// <summary>
        /// Filter string usable at OpenFileDialog windows. Allows filtering to show only the supported file formats
        /// </summary>
        public string fileFilters
        {
            get;
            private set;
        }


        /// <summary>
        /// A list of strings encoding all the allowed combinations of individual movements.
        /// Each combination string is a comma-separated list of numbers, e.g.: "1,3,5" or "2,4"
        /// </summary>
        public StringCollection allowedComplexMovements { get; set; }



        /// <summary>
        /// Number of valid single movements including rest
        /// </summary>
        public int numSingleMovements { get; set; }



        private RecordingConfig _thresholdRecordingConfig;
        /// <summary>
        /// RecordingConfig object for threshold-based movement recognition.
        /// </summary>
        public RecordingConfig thresholdRecordingConfig
        {
            get
            {
                return _thresholdRecordingConfig;
            }

            set
            {
                if (thresholdRecordingConfig != value)
                {
                    _thresholdRecordingConfig = value;
                    this.NotifyPropertyChanged("thresholdRecordingConfig");
                }
            }
        }



        /// <summary>
        /// Basic attribute initialization. Full configuration must be performed by a client class using this model.
        /// </summary>
        public AcqModel()
        {
            this.PropertyChanged += AcqModel_PropertyChanged;
            recordingConfig = new RecordingConfig();
            recordedData = new Recording(recordingConfig);
            _acqPipeline = new Pipeline();
            dataProvider = "none";
            _selectedMovements = new ObservableCollection<Movement>();
            _selectedMovements.CollectionChanged += SelectedMovements_CollectionChanged;
            recordingValid = false;

            _fileReadWriters = new List<IFileReadWriter>();
            
            //Initialization of available IFileReadWriters
            _fileReadWriters.Add(new HDF5RecordingReadWriter());
            
            //Composing filter string
            fileFilters = "";
            
            foreach (IFileReadWriter fileReadWriter in _fileReadWriters)
            {
                fileFilters = fileFilters + fileReadWriter.supportedFormats.ToString() + "|";
            }

            fileFilters = fileFilters + "All Files (*.*)|*.*";
        }



        /// <summary>
        /// Composes a recording schedule by using as inputs the list of selected movements, the number of 
        /// simultaneous movements and checking the restrictions for combining movements
        /// </summary>
        public void ComposeSchedule()
        {
            ObservableCollection<ScheduleItem> schedule = recordingConfig.schedule;
            List<ushort[]> provList = new List<ushort[]>();
            ushort[] movement;

            if ((_selectedMovements.Count <= 0) || (simultMovements <= 0)) return;
    

            if (_simultMovements > 1) recursiveCompose(provList, new ushort[_simultMovements], 0, 0);

            else
            {
                for (int i = 0; i < _selectedMovements.Count; i++)
                {
                    movement = new ushort[_simultMovements];
                    movement[0] = (ushort)_selectedMovements.ElementAt(i).idTag;
                    provList.Add(movement);
                }
            }


            if (provList.Count > 0)
            {
                //At this point we should have a list of allowed compound movements created from the list
                //of selected simple movements and the number simultaneous movements selected. Now we compose
                //a schedule including rests and repetitions

                //Adding as much initial rests as WarmupItems are configured in the recording configuration. These
                //WILL NOT BE RECORDED

                MovListToCodeConverter converter =
                    new MovListToCodeConverter(numSingleMovements
                                                , allowedComplexMovements);

                for (int i = 0; i < recordingConfig.scheduleWarmupItems; i++)
                {
                    movement = new ushort[1];
                    movement[0] = 0;
                    schedule.Add(new ScheduleItem((int)converter.Convert(movement,null,null,null), movement));
                }

                for (int i = 0; i < provList.Count; i++)
                {
                    for (int j = 0; j < recordingConfig.repetitions; j++)
                    {
                        schedule.Add(new ScheduleItem((int)converter.Convert(provList.ElementAt(i),null,null,null), provList.ElementAt(i)));

                        movement = new ushort[1];
                        movement[0] = 0;
                        schedule.Add(new ScheduleItem((int)converter.Convert(movement,null,null,null), movement)); //An rest after each movement
                    }
                }

                //The schedule is now complete.
            }
        }



        /// <summary>
        /// Performs the composition of the schedule by recursively finding allowed movement combinations that are possible
        /// using the selected movements.
        /// </summary>
        /// <param name="movementList"></param>
        /// <param name="movement"></param>
        /// <param name="startPosition"></param>
        /// <param name="currentElement"></param>
        private void recursiveCompose(List<ushort[]> movementList, ushort[] movement, int startPosition, int currentElement)
        {
            ushort[] temp;
            int maxIndex = _selectedMovements.Count - _simultMovements + currentElement;


            for (int i = startPosition; i <= maxIndex; i++)
            {
                temp = new ushort[_simultMovements];
                movement.CopyTo(temp, 0);
                temp[currentElement] = (ushort)_selectedMovements[i].idTag;

                if (currentElement == (_simultMovements - 1))
                {
                    //Add this combination to the list 
                    if (_simultMovements > 1)
                    {
                        //Check if the combination is allowed
                        string movAsString = "";

                        //First we turn the array of simple movements defining a complex movement into a string with a specific format.

                        for (int j = 0; j < temp.Length; j++)
                        {
                            if (j > 0) movAsString = movAsString + ",";
                            movAsString = movAsString + String.Format("{0}", temp[j]);
                        }

                        //If there is such a string in the configuration parameter that determines the valid combinations of
                        //simple movements, then we add it to the movement list.

                        if (allowedComplexMovements.Contains(movAsString))
                            movementList.Add(temp);
                    }
                    else movementList.Add(temp);

                }
                else
                {
                    //Recursive call
                    recursiveCompose(movementList, temp, startPosition + 1, currentElement + 1);
                }
            }
        }


        //Initialisation operations such as reading configuration and setting up of resources
        public void Init()
        {
            _recordingController = new AcquisitionController(_acqPipeline);
            _recordingController.numSingleMovements = numSingleMovements;
            _recordingController.allowedComplexMovements = allowedComplexMovements;
            _recordingStage = new Recorder(recordedData);
            _recordingStage.PropertyChanged += _recordingStage_PropertyChanged;
            _thresholdEngine = new ThresholdEngine();
            _thresholdEngine.recordingConfig = recordingConfig;
            _thresholdEngine.windowLength = 200;


            //We build and initialise the pipeline
            _acqPipeline.AddStage(_recordingController);
            _acqPipeline.AddStage(_thresholdEngine);
            _acqPipeline.AddStage(_recordingStage);
        }


        void _recordingStage_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            switch (e.PropertyName)
            {
                case "recording":
                    this.NotifyPropertyChanged("recordedData");
                    break;
                default:
                    break;
            }
        }

        public void StartRecording()
        {

            //ComposeSchedule();

            recordedData.data.Clear();
            this.NotifyPropertyChanged("recordedData");

            if(detectThresholds) recordingConfig.thresholdSet.ClearStats();
            recordingValid = false;

            _thresholdEngine.enabled = detectThresholds;
            _recordingController.recordingConfig = recordingConfig;
            _recordingController.dataProvider = _dataProvider;

            try
            {
                _acqPipeline.Init();
            }
            catch (AcquisitionControllerException ex)
            {
                throw new AcqModelException("Pipeline.Init:" + ex.Message);
            }

            _acqPipeline.Start();
        }


        public void StopRecording()
        {
            _acqPipeline.Stop();

            if (detectThresholds)
            {
                RecordingConfig temp = new RecordingConfig();
                temp.Copy(recordingConfig);
                thresholdRecordingConfig = temp;
            }

            recordingValid = true;
        }

        public void PauseRecording()
        {
            _dataProvider.Pause();
        }

        public void ResumeRecording()
        {
            _dataProvider.Start();
        }


        /// <summary>
        /// Obtains an IFileReadWriter that will open files for the given extenson
        /// </summary>
        /// <param name="extension">The extension of the file to open</param>
        /// <returns></returns>
        private IFileReadWriter GetFileReadWriter(string extension)
        {
            IFileReadWriter selectedReadWriter = null;

            foreach (IFileReadWriter fileReadWriter in _fileReadWriters)
            {
                if (fileReadWriter.supportedFormats.ToString().Contains(extension))
                {
                    selectedReadWriter = fileReadWriter;
                    break;
                }
            }


            return selectedReadWriter;
        }


        public void LoadFromFile(string filename)
        {
            string extension = Path.GetExtension(filename);
            IFileReadWriter selectedReadWriter = GetFileReadWriter(extension);

            if (selectedReadWriter != null)
            {
                recordedData.data.Clear();

                selectedReadWriter.allowedComplexMovements = Properties.Settings.Default.AcqAllowedMovements;
                selectedReadWriter.knownMovements = Properties.Settings.Default.AcqMovementsList;
                selectedReadWriter.movementSelector = new DialogMovementSelector();
                try
                {
                    selectedReadWriter.ReadFile(filename, recordedData);
                    recordingValid = true;
                }
                catch (IFileReadWriterException e)
                {
                    throw new AcqModelException("LoadFromFile: Error reading from file",e);
                }
            }
            else throw (new AcqModelException("LoadFromFile: Could not select an appropriate reader for this file type!"));
        }


        public void SaveToFile(string filename)
        {
            string extension = Path.GetExtension(filename);
            IFileReadWriter selectedReadWriter = GetFileReadWriter(extension);

            if (selectedReadWriter != null)
            {
                selectedReadWriter.allowedComplexMovements = Properties.Settings.Default.AcqAllowedMovements;
                selectedReadWriter.knownMovements = Properties.Settings.Default.AcqMovementsList;
                selectedReadWriter.movementSelector = new DialogMovementSelector();
                try
                {
                    selectedReadWriter.WriteFile(filename, recordedData);
                }
                catch (IFileReadWriterException e)
                {
                    throw new AcqModelException("SaveToFile: Error writing to file", e);
                }
            }
            else throw (new AcqModelException("SaveToFile: Could not select an appropriate writer for this file type!"));
        }

    }
}
