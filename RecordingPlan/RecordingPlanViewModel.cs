/*
 * Copyright 2015 Martin Garcia Carmueja 
 * 
 *  This file is part of the Myoelectric Personal Training and Control Environment (MPTCE).
 *
 *  MPTCE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  MPTCE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with MPTCE. If not, see <http://www.gnu.org/licenses/>.
 */

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.ComponentModel;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using EMGFramework.Timer;
using EMGFramework.ValueObjects;

namespace RecordingPlan
{
    public class RecordingPlanViewModel:INotifyPropertyChanged
    {

        /// <summary>
        /// Event handler that fires whenever a property in the ViewModel has been changed.
        /// </summary>
        public event PropertyChangedEventHandler PropertyChanged;

        public void NotifyPropertyChanged(string propName)
        {
            if (this.PropertyChanged != null)
                this.PropertyChanged(this, new PropertyChangedEventArgs(propName));
        }



        private List<BitmapImage> _imageList;

        private RecordingConfig _recordingConfig;

        public RecordingConfig recordingConfig
        {
            get
            {
                return _recordingConfig;
            }
            set
            {
                _recordingConfig = value;
                this.NotifyPropertyChanged("recordingConfig");
            }
        }


        private string[] _basicMovements;



        private RecordingPlan _recordingPlan;

        public RecordingPlan recordingPlan
        {
            get
            {
                return _recordingPlan;
            }
            set
            {
                if (_recordingPlan != value)
                {
                    _recordingPlan = value;
                    this.NotifyPropertyChanged("recordingPlan");
                }
            }
        }


        //private BindingList<PlanItem> _planItemList;

        private BitmapImage placeholderBitmap;
        private BitmapImage completedBitmap;

        /// <summary>
        /// Initializes a RecordingPlanModel form a RecordingConfig object and a list of strings with the basic movements
        /// Moreover, the RecordingPLanModel will subscribe to the events generated by the RecordingConfig object
        /// To update the view when required
        /// </summary>
        /// <param name="recordingConfig"></param>
        /// <param name="basicMovements"></param>
        public RecordingPlanViewModel(RecordingConfig recordingConfig, StringCollection basicMovements)
        {
            _recordingConfig = recordingConfig;
            recordingConfig.PropertyChanged += recordingConfig_PropertyChanged;
            _basicMovements = new string[basicMovements.Count];
            basicMovements.CopyTo(_basicMovements, 0);
            placeholderBitmap = Convert((Bitmap)Properties.Resources.ResourceManager.GetObject("nofoto"));
            completedBitmap = Convert((Bitmap)Properties.Resources.ResourceManager.GetObject("ok"));
            SetSelectedItem(-1);
        }



        void recordingConfig_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            switch (e.PropertyName)
            {
                case "scheduleLength":
                case "scheduleItemTime":
                    BuildPlan();
                    break;
                default:
                    break;
            }
        }


        /// <summary>
        /// It uses the referenced RecordingConfig and StringCollection object containing the list of basic movements
        /// to build a recording plan
        /// </summary>
        public void BuildPlan()
        {
            PlanItem planItem;
            string name;

            if ((_recordingConfig == null) || (_basicMovements == null) || (_recordingPlan.planItemList == null)) return;


            _recordingPlan.planItemList.Clear();

            foreach (ScheduleItem scheduleItem in _recordingConfig.schedule)
            {
                name = "";

                for (int i = 0; i < scheduleItem.movementComposition.Length; i++)
                {
                    name = name + _basicMovements[scheduleItem.movementComposition[i]];
                    if (i < (scheduleItem.movementComposition.Length - 1))
                        name = name + " + ";
                }

                planItem = new PlanItem(_recordingConfig.scheduleItemTime, name, scheduleItem.movementCode);
                _recordingPlan.planItemList.Add(planItem);
            }
        }



        /// <summary>
        /// Sets a given item as selected, moves the focus to it and marks the until then active item as completed
        /// It also sets the movement image accordingly
        /// </summary>
        /// <param name="itemNumber"></param>
        public void SetSelectedItem(int itemNumber)
        {
            if (recordingPlan == null) return;

            if ((itemNumber < 0) || (itemNumber >= _recordingPlan.planItemList.Count))
            {
                foreach (PlanItem item in recordingPlan.planItemList)
                {
                    item.selected = false;
                    item.completed = false;
                }
                _recordingPlan.movementBitmap = placeholderBitmap;

                _recordingPlan.activeItem = 0;
            }

            else
            {
                PlanItem item = _recordingPlan.planItemList.ElementAt(itemNumber);
                item.selected = true;
                if (itemNumber > 0) _recordingPlan.planItemList.ElementAt(itemNumber - 1).completed = true;

                if ((itemNumber < (recordingPlan.planItemList.Count - 1))&&(itemNumber>0)) _recordingPlan.activeItem = itemNumber + 1;
                else if(itemNumber == 0) _recordingPlan.activeItem = itemNumber;

                if ((_imageList != null) && (_imageList.Count > 0))
                    if ((item.itemCode == 0) && (itemNumber < (_recordingPlan.planItemList.Count - 1)))
                        _recordingPlan.movementBitmap = _imageList.ElementAt(_recordingPlan.planItemList.ElementAt(itemNumber + 1).itemCode);
                    else if ((item.itemCode == 0) && (itemNumber == (_recordingPlan.planItemList.Count - 1)))
                        _recordingPlan.movementBitmap = completedBitmap;
                    else _recordingPlan.movementBitmap = _imageList.ElementAt(_recordingPlan.planItemList.ElementAt(itemNumber).itemCode);
            }
        }


        /// <summary>
        /// Sets the progress bar of the RecordingPlan widget to the value specified
        /// </summary>
        /// <param name="progress"></param>
        public void SetProgress(int progress)
        {
            if ((progress >= 0) && (progress <= 100))
                _recordingPlan.movementProgress = progress;
        }


        /// <summary>
        /// Composes a list of images that can be used for the RecordingPlan control to display 
        /// the appropriate image for each item in the schedule.
        /// </summary>
        public void SetImages(List<Bitmap> images)
        {
            _imageList = new List<BitmapImage>();

            foreach (Bitmap image in images) if (image!=null) _imageList.Add(Convert(image));

        }

        /// <summary>
        /// Converts GDI+ type bitmap into a WPF type bitmap
        /// </summary>
        /// <param name="bitmap"></param>
        /// <returns></returns>
        private BitmapImage Convert(Bitmap bitmap)
        {
            MemoryStream ms = new MemoryStream();
            bitmap.Save(ms, System.Drawing.Imaging.ImageFormat.Bmp);
            BitmapImage image = new BitmapImage();
            image.BeginInit();
            ms.Seek(0, SeekOrigin.Begin);
            image.StreamSource = ms;
            image.EndInit();

            return image;

        }




    }
}
